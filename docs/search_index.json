[
["index.html", "About Jefferys’ Dockers JefferysDockers", " About Jefferys’ Dockers Stuart R. Jefferys 2020-09-23 JefferysDockers An overview of the Dockers available from Jefferys/JefferysDockers, including the labeling schema and a description of the development goals and build decisions. "],
["dockers.html", "1 Dockers 1.1 Base Dockers", " 1 Dockers 1.1 Base Dockers 1.1.1 ubu-lts - Ubuntu Long Term Support Release A from scratch build of a minimal Ubuntu OS using a tarball of the core Ubuntu distro. This is a big repo due to the tarball, and will get bigger with each Ubuntu version upgrade. Best to do a git clone --depth 1 to avoid downloading all the old tarballs too. "],
["build-methodology.html", "2 Build methodology", " 2 Build methodology A description of the process and conventions used to build the Docker images and publish them. [TODO Work on this.] "],
["label-schema.html", "3 Label Schema 3.1 The LABEL instruction 3.2 Image label standards 3.3 Better heritable tags 3.4 io.github.jefferysdockers Label Schema", " 3 Label Schema Note: I’m only considering labels on images built from Dockerfiles, not images modified interactively and then saved and shared. 3.1 The LABEL instruction The goal of the LABEL Dockerfile instruction is to specify metadata as key=“value” entries that can be inspected, e.g. with docker info &lt;imageName&gt;. Labels can also be added at build time by using the docker build --label &quot;key=value&quot; option. Note: Adding a label at build time could break the build cache, but it is implemented smartly; labels are added at the end of the build, so if a new or different label is added to a previously-run build command, everything is preserved except for the final step. Even the “add labels” step is cached and reused if the build command uses the same labels [SRJ in the same order?]. 3.2 Image label standards There are more than one labeling standard, none of which are complete. So I just use them for source info on what kinds of labels I want. My notes on them follow in the sections Open Containers Standard{open-containers-standard} and Biocontainers Standard What’s missing is that metadata needs to be inherited in a hierarchy, not flat. Flat means values inherited from parents are lost when a child declares a label of the same name, and if a child does not define a label the parent does, it is inherited with no indication of where it came from - e.g. the email of the maintainer. To add this without changing how docker formats labels is the trick. It requires every image to have its own unique namespace prefix that is used as a prefix for all its labels. Then each (reverse-domain-name prefixed) label inherited is preserved and associate with a specific parent image. 3.3 Better heritable tags 3.3.1 Adding image namespaces. The reverse-domain name of the image hosting site provides an ideal unique name, when combined with the image name (with “/” replaced by “.”). Since com.dockerhub.* is reserved, docker-hub hosted images have only the name. For a quick example: A io.github.JefferysDockers.pull label is intended to hold the exact syntax needed to pull an image in a docker pull statement. If the image to be labeled is hosted at DockerHub in a repository named jefferys/ubu-lts, the label can be added either in the Dockerfile using the LABEL command or on the build command line using the --label option. In the Dockerfile this would look like LABEL jefferys.ubu-lts.io.github.JefferysDockers.pull=&quot;jefferys/ubu-lts:20.04.01-0.0.1&quot; On the docker build command line it would look like docker build --label &quot;jefferys.ubu-lts.io.github.JefferysDockers.pull=jefferys/ubu-lts:20.04.01-0.0.1&quot; In general no image will have a different version of itself as its base (or as any base, recursively), so tags are not used to identify images uniquely. If necessary in some specific instance they could always be used. 3.3.2 Specifying the image hierarchy In order to tell which tag goes with which inherited image, and which is from the current, a special (prefixed) label: io.github.JefferysDockers.base-prefix must be included that identifies the prefix the parent uses. An image defined from scratch has base-prefix=&quot;scratch&quot;. If the parent does not conform to this labeling schema, base-prefix=&quot;&quot;, the empty string. When the recursive chain of images all conform, the chain of images can be recreated by parsing all base-prefix labels. The base-prefix label whose base prefix is not specified by any base-prefix is then the most recent. For example a scratch image ubu-lts providing an Ubuntu OS could define: LABEL jefferys.ubu-lts.io.github.JefferysDockers.base-prefix=&quot;scratch&quot; An image r-lang that provided the R programming environment that used “ubu-lts” as its base image could define LABEL jefferys.r-lang.io.github.JefferysDockers.base-prefix=&quot;jefferys.ubu-lts&quot; The r-lang image will inherit the labels from its base, and since the prefix of the base-prefix label differs, both the parent’s and the child’s labels are present. Adding third “application” image that provided an R programming framework called my-app that had r-lang as its base could define: LABEL jefferys.my-app.io.github.JefferysDockers.base-prefix=&quot;jefferys.r-lang&quot; Its image will inherit its base image labels, which inherits its own base’s image labels, etc. So the labels on the image my-app include all three base-prefix label variants: jefferys.ubu-lts.io.github.JefferysDockers.base-prefix=&quot;scratch&quot; jefferys.r-lang.io.github.JefferysDockers.base-prefix=&quot;jefferys.ubu-lts&quot; jefferys.my-app.io.github.JefferysDockers.base-prefix=&quot;jefferys.r-lang&quot; 3.3.3 Parsing the image chain Parsing the image prefix from each io.github.JefferysDockers.base-prefix label and associating it with the label value allows reconstructing the chain of images and identifies the current image: jefferys.ubu-lts had base scratch jefferys.r-lang had base jefferys.ubu-lts jefferys.my-app had base jefferys.r-lang As jefferys.my-app appeared in no base-prefix label, it is the current image. If we know that all images in the image chain are labeled to conform with this io.github.JefferysDockers standard, then this is all we need. However, it is likely that some image or images in the chain will be non-conforming and labeled in some other way. If a non-conforming image is used anywhere in the chain of images, as the labels on the current image are inherited from all parents, the current image will be non-confirming. It will then not be possible to determine where its labels or the labels it inherits came from. Although that is no different then the current default situation with labels, we would need to be able to detect non-conforming images, and it would be nice to use the labels from any images that do conform. It is always possible to identify a conforming “scratch” base image and a continuous chain of images up to a non-conforming one. But it is not possible to determine if the current image is conforming inspecting “base-prefix” labels on the image. If the current image declares no labels, it will not be detected even if all the other images in the chain are conforming. 3.3.4 Verifying the last image in the chain Unfortunately there seems no way to identify the current image as a conforming image using just the docker inspect command. It is not possible to specify a label that is not inherited, and if it were possible to identify which image in a chain of images a particular label came from, there would be little need for this schema. But there is another tool available to examine images, the docker history command. The docker history command provides information on each build step used to generate an image, including the steps used to build its base image, and its base’s base image, recursively. But although it lists the steps in order, it does not identify which image a step came from - the line between the steps in an image and in its base is not preserved. If it was, we could just use the history information instead of label prefixes to identify what image a label was specified for. But we do have an ordering, so we can tell which is the last step, which must come from the last image. If we can identify the last step as a step the builds a conforming image, we know the current image is conforming and can trace all the labels back to the first non-conforming image. To ensure the current image is detectable as a conforming image, we specify that the last instructions in the image history must be one or more LABEL instructions, and one of the labels set must be (an image namespace prefixed) “io.github.JefferysDockers.label-schema-version” label. When searching backwards through the output of the docker history command, if anything other than a LABEL instruction is encountered before the required “io.github.JefferysDockers.label-schema-version” label, the current image is non-conforming. Docker generally alphabetizes the label instructions based on the label name, so always need to look through the set of all label instruction at the end of the file, not just the last one. (The label keys are also alphabetized in the in the results from inspecting the image.) 3.3.5 An example of parsing an image chain from labels For example, an image might contains the labels: jefferys.my-app.io.github.JefferysDockers.base-prefix=&quot;&quot; jefferys.my-app.io.github.JefferysDockers.label-schema-version=&quot;0.0.2&quot; jefferys.ubu-lts.io.github.JefferysDockers.base-prefix=&quot;scratch&quot; jefferys.ubu-lts.io.github.JefferysDockers.label-schema-version=&quot;0.0.1&quot; And the most recent command indicated in history output is LABEL jefferys.my-app.io.github.JefferysDockers.label-schema-version=&quot;0.0.2&quot; This can then be parsed forwards from the scratch image, which is a conforming image and has labels with prefix jefferys.ubu-lts. There is at least one non-conforming image in the image chain as the image that used ubu-lts as its base is not identifiable. It can also be parsed backwards from the current image, which is a conforming image and has labels with the prefix &quot;jefferys.my-app&quot;. The base of the current image is non-conforming, and so its prefix is specifically unspecified (as &quot;&quot;). There is an unknown number of non-conforming images between the conforming scratch and the conforming current images. 3.3.6 Summary The need to parse history and inspect output to determine image hierarchy and associate labels with images is not ideal, but there seems no other way to implement image-specific labels without support from the container specification itself. Doing so avoids the problems of stale image labels inherited by current images that don’t over-write them, stops one image from overwriting labels from base or prior images that might be important, and allows for accumulative labels that span the whole image, such as licenses. It is relatively robust and not too difficult to implement, requiring two specific labels per container. 3.4 io.github.jefferysdockers Label Schema 3.4.1 Required prefixes All labels must be prefixed by the full reverse domain name for the image pull command, converting slashes to periods and leaving out a leading com.dockerhub. if needed. For example, if an image primary hosting is at dockerhub.com/jefferys/ubu-lts its prefix would be jefferys.ubu-lts. Following the image prefix, images should be labeled by the reverse domain name of the schema where the labels are defined. This schema is defined at jefferysdockers.github.io so its labels are specified with a prefix of io.github.jefferysdockers. So in total, all labels from this schema in the above image would have a prefix of jefferys.ubu-lts.io.github.jefferysdockers. Labels from other schema can be included in conforming containers, but must also have the image hosting prefix in addition to their domain specific labels, or even simple labels. For example other labels added to the image for some use cases might look like: jefferys.ubu-lts.com.example.rating=&quot;10&quot; jefferys.ubu-lts.com.needs-mem=&quot;32G&quot; It is permissible to add a simple label like needs-mem=&quot;32G&quot; to an image for purely local use, but such labels should never be used on shared hosted images, and care must be taken by local users in labeling images used as the base for another. Note: Since there are required labels, and only conforming images should use the io.github.jefferysdockers. prefixes, it is always possible to parse the image name prefix preceding such a label, and hence user labels are can be parsed as well. 3.4.2 Required labels io.github.JefferysDockers.base-prefix - Declares the prefix used in the base image. […] By specifying the prefix the base image uses to identify its labels, image -&gt; base image relationships can be deduced. Must be &quot;scratch&quot; if an image has no base, and must be &quot;&quot; (the empty string) if the base image does not conform to the io.github.JefferysDockers labeling standard. Examples: LABEL jefferys.ubu-lts.io.github.JefferysDockers.base-prefix=&quot;scratch&quot; LABEL jefferys.bioc.io.github.JefferysDockers.base-prefix=&quot;&quot; io.github.JefferysDockers.label-schema-version - The version of the io.github.JefferysDockers labeling schema a conforming image uses. […] Must be specified last in the Dockerfile or be followed only by LABEL statements. It may also be specified on the build command line using the --label option as those are added into the container at the end as LABEL instructions. Examples: LABEL jefferys.ubu-lts.io.github.JefferysDockers.label-schema-version=&quot;0.0.1&quot; docker build --label &quot;jefferys.ubu-lts.io.github.JefferysDockers.label-schema-version=0.0.1&quot; [TODO - CONTINUE FROM HERE] 3.4.3 Optional Labels [TODO - CONTINUE FROM HERE] 3.4.4 Example build script This is essentially the build.sh for the ubu-lts base Docker, with several optimizations to use with DockerHub’s automated build environment, which includes the environmental variables: $DOCKER_REPO - The base name of the repo that will be pulling and building this $DOCKERFILE_PATH - The path to the Dockerfile, relative to the root of the build source repo. &quot;TAG&quot; - The name of the file containing the full version tag to use, as - In reality this will be in a file “hooks/build”, the real build.sh in the repo just calls this script and provides values for the ENV variables above, if not specified ### # Label input parameters ### # Describing the image imageName=&quot;${DOCKER_REPO}&quot; dockerfilePath=&quot;${DOCKERFILE_PATH}&quot; spdxLicense=&quot;&quot; licenseFile=&quot;https://ubuntu.com/licensing&quot; baseImagePrefix=&quot;scratch&quot; title=&quot;${imageName} - Base OS derived from Ubuntu.&quot; description=&quot;Based on Ubuntu this is a completely local build of a base Docker from scratch.&quot; keywords=&quot;Linux, Ubuntu, scratch, os&quot; # Describing the image&#39;s content (the included Ubuntu distro) contentHome=&quot;https://wiki.ubuntu.com/Base&quot; contentSource=&quot;http://cdimage.ubuntu.com/ubuntu-base/&quot; contentTitle=&quot;Ubuntu base os distribution&quot; contentDescription=&quot;Minimalist non-official functional distribution of Ubuntu, including apt-get&quot; contentSpdxLicense=&quot;&quot; contentLicenseFile=&quot;https://ubuntu.com/licensing&quot; contentVendor=&quot;Canonical&quot; contentVendorUrl=&quot;https://canonical.com/&quot; # Independent of image and content labelSchemaVersion=&quot;0.0.1&quot; vendor=&quot;UNC - Lineberger&quot; vendorUrl=&quot;https://lbc.unc.edu/&quot; # Constant across my dockers labelSchema=&quot;io.github.JefferysDockers&quot; imageRepoOwner=&quot;jefferys&quot; sourceRepoOwner=&quot;JefferysDockers&quot; imageRepoRootUrl=&quot;https://hub.docker.com/r&quot; sourceRepoRootUrl=&quot;https://github.com&quot; maintainer=&quot;Stuart R. Jefferys &lt;stuart_jefferys@med.unc.edu&gt;&quot; ### # End of label input parameters ### # Get tag for image, and parse into parts: the before first &quot;-&quot; part (the tool # version) and the after first &quot;-&quot; part (the build version). read TAG &lt; &quot;TAG&quot; contentVersion=&quot;${TAG%%-*}&quot; sourceVersion=&quot;${TAG#*-}&quot; # Time created created=&quot;$(date &quot;+%Y-%m-%dT%H:%M:%S%z&quot;)&quot; afterPos=$(( ${#created} - 2 )) created=&quot;${created:0:${afterPos}}:${created:${afterPos}}&quot; # Full label namespace with unique image id prepended NS=&quot;${imageRepoOwner}.${imageName}.${labelSchema}&quot; ### # Build command. ### docker build \\ --label &quot;${NS}.base-prefix=${baseImagePrefix}&quot; \\ --label &quot;${NS}.name=${imageName}&quot; \\ --label &quot;${NS}.home=${imageRepoRootUrl}/${imageRepoOwner}/${imageName}&quot; \\ --label &quot;${NS}.version=${TAG}&quot; \\ --label &quot;${NS}.maintainer=${maintainer}&quot; \\ --label &quot;${NS}.source-version=${sourceVersion}&quot; \\ --label &quot;${NS}.source-home=${sourceRepoRootUrl}/${sourceRepoOwner}/${imageName}&quot; \\ --label &quot;${NS}.source-maintainer=${maintainer}&quot; \\ --label &quot;${NS}.pull=${imageRepoOwner}/${imageName}:$TAG&quot; \\ --label &quot;${NS}.license-spdx=${spdxLicense}&quot; \\ --label &quot;${NS}.license-file=${licenseFile}&quot; \\ --label &quot;${NS}.vendor=${vendor}&quot; \\ --label &quot;${NS}.vendorUrl=${vendorUrl}&quot; \\ --label &quot;${NS}.title=${title}&quot; \\ --label &quot;${NS}.description=${description}&quot; \\ --label &quot;${NS}.content-home=${contentHome}&quot; \\ --label &quot;${NS}.content-version=${contentVersion}&quot; \\ --label &quot;${NS}.content-source=${contentSource}&quot; \\ --label &quot;${NS}.content-license-spdx=${contentSpdxLicense}&quot; \\ --label &quot;${NS}.content-license-file=${contentLicenseFile}&quot; \\ --label &quot;${NS}.content-vendor=${contentVendor}&quot; \\ --label &quot;${NS}.content-vendorUrl=${contentVendorUrl}&quot; \\ --label &quot;${NS}.content-title=${contentTitle}&quot; \\ --label &quot;${NS}.content-description=${contentDescription}&quot; \\ --label &quot;${NS}.created=${created}&quot; \\ --label &quot;${NS}.label-schema-version=${labelSchemaVersion}&quot; \\ --tag &quot;${imageRepoOwner}/${imageName}:latest&quot; \\ --tag &quot;${imageRepoOwner}/${imageName}:${contentVersion}&quot; \\ --tag &quot;${imageRepoOwner}/${imageName}:${contentVersion}-${sourceVersion}&quot; \\ -f ${dockerfilePath} \\ . "],
["other-label-schemas.html", "4 Other Label Schemas 4.1 Open Containers Standard 4.2 Biocontainers Standard", " 4 Other Label Schemas 4.1 Open Containers Standard The standard is specified here: https://github.com/opencontainers/image-spec/blob/master/annotations.md 4.1.1 Labels Labels are components of a = map, where keys and values are strings 4.1.2 Keys Keys should be qualified by prefixing with reverse domain names to ensure uniqueness. Keys or prefixes matching org.opencontainers.* and org.opencontainers.image.* are reserved by the specification and only have the meanings defined therein. [SRJ: Nothing says that keys can’t contain spaces and weird characters. Is that true? I bet not.] Anything reading labels should handle unknown keys without error. 4.1.3 Values All values must be strings and there must be a value if a key is defined (it may be &quot;&quot;, the empty string). 4.1.4 Pre-defined keys org.opencontainers.image.created - The date and time the image was created. [...] This must be a string formatted in accordance with RFC 3339. For example: &quot;2020-09-12T00:23:06-04:00&quot; or &quot;2020-09-12 00:23:06-04:00&quot; One way to get such a string portably, including apple’s OS X, is as follows. (Most of the complexity is to get the colon into the time zone offset:) imageCreated=&quot;$(date +&quot;%Y-%m-%dT%H:%M:%S%z&quot;)&quot; insertAfterPos=$(( ${#imageCreated} - 2 )) imageCreated=&quot;${imageCreated:0:insertAfterPos}:${imageCreated:insertAfterPos}&quot; Note that adding this into the container will break caching for any following steps as this will never be the same for two successive builds. org.opencontainers.image.authors - The contact details of the people or organization responsible for the image. [...] This is a free-form string, so users should really define their own more constrained label, and copy its contents to this label. One common format for an authors string might look like: org.opencontainers.image.authors = &quot;bob &lt;bob@nowhere.com&gt;; mary&lt;mary@here.com&gt; ; this is ok too &lt; good@good.net &gt;; &lt;alsoOk@my.edu&gt;&quot; syntax Element structure authorsString contact [[; contact] contact [[ name ] &lt; emailAddress &gt; name Any character sequence, possibly with internal spaces, but not “&lt;” characters or newlines. Leading and trailing spaces are stripped. If not present, emailAddress will be used as name. emailAddress Any valid email address, possibly with the exception of not allowing a “&gt;” character. Leading and trailing spaces are stripped. May not be empty Parsing a contact after a split on “;” can then be done with a regexp like: \\s*(.*?)\\s*[&lt;]\\s*(.+?)\\s*[&gt;]\\s* Where the first capture group grabs the name (if present) and the second grabs the emailAddress. It ignores leading and trailing spaces both on the contact as a whole and on the name and emailAddress section [SRJ: How efficient is this? Do the non-greedy capture groups require a lot of back-off re-testing?] If name is empty, it should be set to emailAddress. org.opencontainers.image.url - URL to get information about the image from. [...] [SRJ: I’m assuming this is a link to the image “home” as much as that is possible]. I would like it to be the URL to download an image from, but that seems not to be what this is and there is no such thing in the list] This is, for example, the DockerHub URL for the container. org.opencontainers.image.url=&quot;https://hub.docker.com/repository/docker/jefferys/ubu-lts&quot; org.opencontainers.image.documentation - URL to get documentation on the image. [...] [SRJ: It is not that obvious what “org.opencontainers.image.url” is, given this exists. The only thing I can think is that the url WAS supposed to be where the image is downloaded from, and THIS is supposed to be a link to the home. But if not then maybe the image home does not provide obvious links to documentation about the image, or maybe there are separate summary and detailed documentation for the image. Otherwise this is just the same as org.opencontainers.image.url.] For example, the DockerHub URL for the container, or a link to the readme in the source repository the image is build from. org.opencontainers.image.url=&quot;https://hub.docker.com/repository/docker/jefferys/ubu-lts&quot; or org.opencontainers.image.url=&quot;https://github.com/JefferysDockers/ubu-lts/README.md&quot; org.opencontainers.image.source - URL to get the source code for building the image. [...] This is, for example, the GitHub URL for a repo containing the context and the Dockerfile. It might be a sub-directory within the repo, in which case this URL should point to that. If any parameters are needed to build the container, or any special pre-processing is needed, that should be documented in a README or README.md alongside the Dockerfile, or in the Dockerfile itself. [SRJ- there should be a label for a URL to point to this, as the BUILD documentation is separate from the USER documentation.] org.opencontainers.image.version - Version of the packaged software. [...] This is the version of the tool that is being packaged in the repository. It is conventional to have a tag for the image that has two parts, tool version and build version, separated by a “-”. This is the tool version. Note that even when the image tag used for accessing an image is “latest”, or something similar, the actual version of the image downloaded should be the value of this. It would be hard to do otherwise. For example, if tagging a base container providing version 20.04.01 of Ubuntu, built with version 0.0.3 of the build software, the tag would be 20.04.01-0.0.3 and this label would be: org.opencontainers.image.version=&quot;20.0.4&quot; org.opencontainers.image.revision - Source control revision identifier for the packaged software. [...] This is the version of the source code repository that contains the build context and a Dockerfile for building a container. It is conventional to have a tag for the image that has two parts, tool version and build version, separated by a “-”. This is the build version. For example, if tagging a base container providing version 20.04.01 of Ubuntu, built with version 0.0.3 of the build software, the tag would be 20.04.01-0.0.3 and this label would be: org.opencontainers.image.revision=&quot;0.0.3&quot; org.opencontainers.image.vendor - Name of the distributing entity, organization or individual. [...] This could be the owner of the DockerHub repo or the GitHub repo, but since those might be different and this is not explicit, this only refers to an abstract “owner” that is producing the image and making it available. This is not the maintainer. For example, a base image container for Ubuntu might have: org.opencontainers.image.vendor=&quot;Cannonical&quot; org.opencontainers.image.licenses - License(s) under which contained software is distributed as an SPDX License Expression. [...] This is not supposed to be the license of the source repository used to build the image, but is transitive from the packaged “tool”. Unfortunately, this is problematic as main part of the image is actually the composite OS from the base (or directly for base images) that do not have simple licenses. This makes this close to useless for anything except closed source private containers. In which case there is likely no difference in license between the container and the source repo. Specifying the terms under which all the software in the image, and hence the image itself can be distributed is too complex. Given that, I’m using this to mean the license of the SOURCE repo that built the container. Common ones are: SPDX:Apache-2.0 SPDX:GPL-2.0-or-later SPDX:GPL-3.0-only SPDX:MIT For example org.opencontainers.image.licenses=&quot;SPDX:MIT&quot; org.opencontainers.image.ref.name - Name of the reference for a target (string). [...] The source information for this is very confusing, and seems to indicate this is supposed to be the “tag” for an image, not any of the rest of the name. But the description below is much more extensive. So it looks like this is supposed to be the complete unique name by which this image is known. Since image names are not namespaced except by “/” separated components of the their name, a registry path is needed to do this correctly. But this will not fix that, this will just be the full name without a url. Too bad in this day and age the registry is not part of the standard to allow complete automated pulling of the image. Formal definition of this element is provided here: https://github.com/opencontainers/image-spec/blob/master/annotations.md#pre-defined-annotation-keys Example: org.opencontainers.image.ref.name=&quot;jefferys/ubu-lts:20.04.01-0.0.3&quot; org.opencontainers.image.title - Human-readable title of the image (string) [...] This should be a one-line description, preferably 80 characters or less. Example: org.opencontainers.image.title=&quot;ubu-lts - Base OS docker derived from Ubuntu.&quot; org.opencontainers.image.description - Human-readable description of the software packaged in the image (string) [...] This can be a multi-line-string, but it is subject to Dockerfile string parsing rules and leading spaces or tabs are literally included and can’t be used for “pretty” layout in the file. Example: LABEL org.opencontainers.image.description=&quot;Based on Ubuntu this is a completely local build of a base Docker from scratch.&quot; 4.2 Biocontainers Standard https://github.com/BioContainers/specs/blob/master/container-specs.md To comply with this standard, all required labels must be provided. Many of these overlap with the org.opencontainers.image standard, but are not namespaced names as those are. These have to be provided with duplicate values. It would be nice if this was synced with that and used a “pro.biocontainers.” prefix for these labels. 4.2.1 Pre-defined keys (required): base_image - The original image where the software has been built. […] Conflicting examples. In one example it includes the tag but not the “group/” part of the name. In another example, this includes the group part, but does not include the tag. It should include both, and hence meets my re-definition of “ref.name”, but for the base image. If there is no base image, what this should be is not clear. I’m assuming it can either be the empty string &quot;“, or”scratch&quot;. Example: LABEL base_image=&quot;biodckr/biodocker:latest&quot; Equivalent org.opencontainers.image tag: None version - Version of the images Dockerfile. […] This is the source repository version, usually the second part of a two part tag. Example LABEL version=&quot;0.0.3&quot; Equivalent org.opencontainers.image tag: org.opencontainers.image.revision=&quot;0.0.3&quot; software.version - Version of the software or tool. […] This is the version of the packaged tool, usually the first part of a two-part tag. Example: LABEL software.version=&quot;2020.04.1 Equivalent org.opencontainers.image tag: org.opencontainers.image.version=&quot;20.0.4&quot; software - Name of the software or tool. […] The packaged software or tool. This is usually the basename of the image, without the “group” components Example: software=&quot;ubu-lts&quot; Equivalent org.opencontainers.image tag: None about.summary - A short description of the software or tool. […] Not clear if this can container newlines, but assuming that is ok, so that makes it similar to the Example: LABEL about.summary=&quot;Based on Ubuntu this is a completely local build of a base Docker from scratch.&quot; Equivalent org.opencontainers.image tag: org.opencontainers.image.description=&quot;Based on Ubuntu this is a completely local build of a base Docker from scratch.&quot; about.home - The original software website. […] Unlike org.opencontainers.image.documentation, this is intended to be documentation for the packaged tool, not the image. Example: about.home=&quot;https://wiki.ubuntu.com/Base&quot; Equivalent org.opencontainers.image tag: None about.license - SPDX license specification. […] If a license not in the SPDX list is used, specify the URL in license_file. Example: about.license=&quot;SPDX:MIT&quot; Equivalent org.opencontainers.image tag: org.opencontainers.image.licenses=&quot;SPDX:MIT&quot; maintainer The image maintainer. […] Note that the specification actually usually the MAINTAINER instruction, not a LABEL, but this is deprecated in DOCKERFILES and should not be used. And to be clear, this is the image maintainer, not the maintainer of the source the image is build from, although that is probably the same… The format of this is not specified, but should be a single email contact if possible. Example: LABEL maintainer=&quot;bob &lt;bob@nowhere.com&gt;&quot; Equivalent org.opencontainers.image tag: None 4.2.2 Pre-defined keys (optional): about.documentation - URL(s) with information on the software tool. […] This is a link to documentation on the packaged tool. It is likely good enough just to have the home, but the documentation may be version specific, so a version specific link to documentation is probably a good idea. Example: None Given Equivalent org.opencontainers.image tag: None about.license_file - License path location in the container or url. […] This is not optional if no SPDX license is specified. Example: (None Given) Equivalent org.opencontainers.image tag: None about.tags= Keywords that help to find and classify the software tool. […] This is formatted as a comma separated strings, possibly including spaces. Example: LABEL about.tags=&quot;proteomics, mass spectrometry, biocontainers&quot; Equivalent org.opencontainers.image tag: None extra.identifiers.* - Specify additional labels not in the biocontainers specification. […] Extra identifiers are external identifiers in other resources that will allow to pull metadata, an external information from other resources (e.g biotools). In order to be compatible with Docker specification the domain (database) of the identifiers should be specified in the name of the label. Example: LABEL extra.identifiers.biotools=abyss Equivalent org.opencontainers.image tag: None: All tags are user namespaced, so no need for a defined special tag prefix. "]
]
